package ru.nsk.kstatemachine

/**
 * Base interface for events which may trigger transitions of [StateMachine]
 */
interface Event

/**
 * Event holding some data
 */
interface DataEvent<out D : Any> : Event {
    val data: D
}

/**
 * User may call [StateMachine.processEventBlocking] with [UndoEvent] as alternative to calling machine.undo()
 */
object UndoEvent : Event

/**
 * Marker interface for all events that are generated by the library itself
 */
interface GeneratedEvent : Event

/**
 * Special event generated by the library when a state is finished.
 * Transitions use special event matcher by default to match only related events.
 * If [FinishedEvent] is generated by [FinalDataState] entry, [data] field of event will receive data
 * from this state using [DataExtractor]
 */
class FinishedEvent internal constructor(val state: IState, val data: Any? = null) : GeneratedEvent

/**
 * Initial event which is processed on state machine start
 */
interface StartEvent : GeneratedEvent
internal class StartEventImpl : StartEvent
internal class StartDataEventImpl<out D : Any>(override val data: D) : StartEvent, DataEvent<D>

internal object StopEvent: GeneratedEvent
internal class DestroyEvent(val stop: Boolean): GeneratedEvent

/**
 * System event which is used by the library to wrap original event and argument,
 * so user may access them, when this event is processed.
 * Currently only [UndoEvent] is transformed to this event.
 * @param event original event
 * @param argument original argument
 */
class WrappedEvent(val event: Event, val argument: Any?) : Event

@StateMachineDslMarker
data class TransitionParams<E : Event>(
    val transition: Transition<E>,
    val direction: TransitionDirection,
    val event: E,
    /**
     * This parameter may be used to pass arbitrary data with the event,
     * so there is no need to define [Event] subclasses every time.
     * Subclassing should be preferred if the event always contains data of some type.
     */
    val argument: Any? = null,
)

/**
 * Convenience property for unwrapping original event.
 * If the event is not [WrappedEvent] this is same as [TransitionParams.event] property
 */
val TransitionParams<*>.unwrappedEvent get() = if (event is WrappedEvent) event.event else event

/**
 * Convenience property for unwrapping original argument.
 * If the event is not [WrappedEvent] this is same as [TransitionParams.argument] property
 */
val TransitionParams<*>.unwrappedArgument get() = if (event is WrappedEvent) event.argument else argument
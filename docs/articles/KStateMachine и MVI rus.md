# State machine для контроля состояния в MVI архитектуре на Kotlin.

В этой статье хотелось бы рассмотреть как работают вместе две технологии, это MVI архитектура и State Machine - машина состояний или конечный автомат.
Это может быть интересно так как обе эти технологии используют реактивный подход, события и хранят состояние которое отражает данные приложения.
В результате мы увидим как эти технологии могут сочетаться и дополнять друг друга. 

Мы попробуем написать простое игровое Android приложение где будем использовать два данных подхода.

Для реализации MVI я не будут использовать какой либо фреймворк, так как для наший целей будет достаточно примитивной реализации.
В качестве фреймворка State Machine я буду использовать свою библиотеку KStateMachine, которая доступна на github.com https://github.com/nsk90/kstatemachine

## Повехностно о MVI

Если вы еще не знакомы с этим архитектурным подходом, то наверняка знакомы с широко используемым в Android MVVM. В кратце его можно описать так: это тотже MVVM однако MVI ограничивает колличество потоков данных от ViewModel к View двумя потоками (концептуально он вобще один, но жизненный цикл Android вносит свои коррективы). Это поток состояний (State) и поток одноразовых событий - эффектов (Effect). Поток состояний объединяет все LiveData, которые в MVVM торчат из ViewModel, а поток событий объединяет так называемые SingleLiveEvents. Тем самым View подписывается и получает модель данных целиком, а не по кускам как это происходит в MVVM.
Так у view всегда есть полная картина того в какое состояние должен быть приведен экран. Начальное состояние также задано в модели данных, а не расплывается по xml файлам или настройкам view, как это часто бывает в MVVM из-за реализации LiveData.

```kotlin
class MVVMViewModel {
    val isProgress: LiveData<Boolean>
    val value: LiveData<Int>
}

// vs

data class State(val isProgress: Boolean, val value: Int)

class MVIViewModel {
    val stateFlow: Flow<State> // Flow это тип из библиотеки корутин, который предствляет поток (источник) данных, аналогично Observable/Flowable в RxJava.
}
```

Благодаря этому не нужно во View ломать голову как дождаться двух разрозненных, но связанных между собой обновлений от ViewModel. И во ViewModel препроверять все ли LiveData мы обновили. 
Я нахожу это весьма удобным.

Model - это общая модель наших данных для View, часто это data класс который хранит ВСЕ наши данные (то самое что отличает) данных подход от MVVM. Бывают и sealed классы, но нужно тщательно следить чтобы они не превратились в "команды", что полностью обесценит идею MVI.
Важно отметить что это "публичные" данные (состояние), тоесть тут хранятся только те данные и в том формате чтобы их можно было получать и обрабатывать во View.
View - UI компонент который является потребителем данных (отображает их пользователю). Главное что он каждый раз получает все данные разом, и полностью (обязательно безусловно) приводит себя в соответствие с ними.
Intent - события от UI которые меняют наш Model. В android они часто вырождаются просто в публичные методы ViewModel, которые вызывает View, но могут быть реализованы и как события (представлены data классами), что удобно например для их логирования.
ViewModel - для нее в аббривиатуре MVI места не нашлось) В Android эта сущность хранит и контролирует время жизни Model (так как view уничтожается при смене конфиграции - например перевороте экрана) и служит точкой для взаимодействия с остальной частью системы (приложения), может обращаться в БД, интернет итп.

Важнейшими свойствами MVI является Реактивность, Single State и Unidirectional data flow (UDF).
Со Single State все понятно, мы просто объединяем все данные экрана в одну кучу и посылаем всю кучу целиком при каждом обновлении. А что такое UDF? Не знаю почему прижилось такое название, кажется оно совсем не отражает то что происходит на самом деле. У нас есть View и ViewModel и данные (для обновления состояния экрана) идут по кругу от ViewModel к View и от View к ViewModel (клики итд). Помоему "однонаправленный" тут совсем не подоходящий термин (данные то идут в обе стороны). Вобщем суть в том что получается такой замкнутый цикл, в котором главное это отсутствие беспорядочных связий и взаимодействий между view и ViewModel которыми может грешать например MVP. 

Существует еще множество наворотов на эту простую идею, вроде всевозможных Reducer, Actor и тому подобных классов, но по моему мнению они по большей части либо перетекли из web, либо являются результатом полета фантазии авторов библиотек реализующих MVI подход. Возможно они себя оправдывают в некоторых крупных приложениях, но нам они точно не понадобятся.

Дисскуссии на тему разницы MVI/MVU/MVVM+/итд тоже за пределами данной статьи. На мой взгляд между ними нет никакой существенной разницы, во всем многообразии Model/View подходов. Разница скорее продиктована окружением (языком, платформой, ui фреймворком) где они появлялись. На много более существенной будет разница от того какую библиотеку вы будете использовать в своем проекте, от Васи или Пети и какую гибкость ~~костыли~~ они в них заложили.

Рекомендую ознакомиться с минималистичной реализацией MVI тут.
https://github.com/orbit-mvi/orbit-mvi

## Повехностно о StateMachine

State Machine это удачный подход представления сложного состояния (состоящего из большого кол-ва переменных). Он описывает не только само состояние (как например data class), но и описывает и ограничивает действия которые возможно совершить над ним в определенный момент. 

Реализуется в виде таких компонентов:
Machine (StateMachine) - это конечный (заранее известный) набор состояний и переходов, которые мы моделируем
State - сами состояния
Transition - это переход Machine от одного состояния к другому
Event - событие которое провоцирует переходы между состояниями

На практике большинство библиотек реализующих эту модель поведения (в том числе и упомянутая KStateMachine) с которыми я сталкивался работают следующим образом:
1) Мы описываем StateMachine, объявляем все возможные состояния и переходы между ними
2) Далее мы "запускаем" StateMachine и начинаем посылать туда события. Она полностью контролирует свое состояни, осуществляет все необоходимые переходы внутри, а мы наблюдая за этими переходами выполняем какие либо действия (side effects) полезные для приложения.

Тем самым используя StateMachine мы формируем модель которая реагирует на входящие события определенным ожидаемым образом. И наблюдая (реагируя на изменения) за этой моделью мы легко можем формировать и узнавать текущее состояние 
данных нашего приложения.

## Библиотека StateMachine vs switch/when/if

Может возникнуть вопрос зачем все это нужно ведь всегда можно обойтись флажками и if конструкциями чтобы проверить условия и сформировать результат. Но когда таких флажков и условий много то такой код быстро становится запутанным сложным и не поддерживаемым. В таких макаронах уже страшно что-то менять потомуто риск забыть проверить или сбросить один из флажков очень велик. У нас слишком много свободы, мы можем поменять все что вздумается в любой момент времени, и никто не подскажет что "сейчас это невозможно". 
Поэтмоу мне кажется что ограничение "нашей свободы" это одно из важнейших и **обязательных** свойств StateMachine.

Наверное Вам уже кажется что я слишком пессемизирую и что if-ы вместо StateMachine никто не использует, и современные разработчики имплементируют StateMachine через when/switch функцию в стиле:

```kotlin
fun nextState(currentState: State, event Event): State {
    when(currentState) {
        SomeState1 -> if(event == SomeEvent) return NewState
        // ...
    }
}
```
Надо отметить что это вполне рабочее решение во многих относительно простых случаях и это однозначно лучше чем флажки и if-ы. 
Но тогда чем отличатеся простая StateMachine от сложной? Колличеством состояний? Нет, в этом случае switch/when растетет в длинну линейно и не вызывает особых проблем. Проблемы начинаются когда состояния становятся параллельными (их еще называют ортогональными). Это значит что мы можем иметь несколько активных состояний одновременно. Например чайник может быть холодным или горячим и одновременно с этим может нагреваться или остывать. В такой ситуации моделируя "плоскую" StateMachine мы получим резкий рост количества возможных состояний (комбинаций).
Похожие проблемы возникают когда состояния имеют вложенную структуру.
Например телевизор может быть включен или нет, а отображаться на нем может YouTube или TV канал. Когда телевизор выключен, состояние отображаемого канала не имеют смысла.

В таких случаях подход c switch/when функцией перестает работать хорошо, и без библиотеки уже не обойтись. Реализовать ее самостоятельно не самая простая и тривиальная задача, как может казаться на миниатюрном switch/when примере.

На эту тему есть очень хорошая статья от автора библиотеки XState, которая имплементирует StateMachine в JavaScript:
https://dev.to/davidkpiano/you-don-t-need-a-library-for-state-machines-k7h


## Игровое sample приложение

Перейдем к примерам, давайте попробуем смоделировать поведение героя игры шутера. Мне кажется это неплохой пример так как его достаточно сложно реализовать "на флажках" и достаточно просто с использованием State Machine.

Наш герой будет уметь стрелять перезаряжаться, стоять, сидеть, прыгать, а также осуществлять атаку ногами в воздухе =)

Это и будут те состояния (States) которые мы смоделируем. Очевидно что если завести на каждое состояние по boolean флагу, то очень просто ошибиться и получить игрока, который одновременно стоит и сидит или продолжает стрелять когда у него кончились патроны. Для того чтобы этого избежать нам и нужна StateMachine.

Сразу приложу ссылку на github с полным кодом тестового приложения, наверняка кому-то так будет удобнее.
https://github.com/nsk90/android-kstatemachine-sample

## View/ViewModel (MVI)

Для начала опишем как будет выглядеть взаимодействие View и ViewMedel (то за что отвечает MVI). Опишу тут только самое основное.
Кстати реализаци MVI которая используется в примере занимает всего около 40 строчек, если интересно с ней можно ознакомиться в примере https://github.com/nsk90/android-kstatemachine-sample/blob/main/app/src/main/java/ru/nsk/kstatemachinesample/mvi/Mvi.kt

```kotlin
data class ModelData(val ammoLeft: UInt, val activeStates: List<HeroState>)

sealed interface ModelEffect {
    object AmmoDecremented : ModelEffect
    class StateEntered(val state: HeroState) : ModelEffect
    class ControlEventSent(val event: ControlEvent) : ModelEffect
}


class MainViewModel : MviModelHost<ModelData, ModelEffect>, ViewModel() {
    override val model = model(viewModelScope, ModelData(INITIAL_AMMO, listOf(Standing)))
    // ...
}
```
ModelData это mvi стостояние (mvi state). Одно из его полей это `List<HeroState>` - набор текущих состояний нашего героя (это стостояния StateMachine) о них поговорим позже, к сожалению терминология пересекается.

Мы наследуемся от стандартной androidx.ViewModel и MviModelHost, нам нужно инициализировать MVI фреймворк  начальным состоянием ModelData (вызвать model функцию).

Как мы уже знаем в mvi у нашей ViewMedel есть 2 публичных потока данных (kotlin.Flow из библиотеки корутин), один с ModelData, другой с ModelEffect (заменитель SingleLiveEvents) 

View подписывается на оба этих потока при создании и ловит события которые из них прилетают.

```kotlin
class MainFragment : Fragment() {
    private val viewModel by viewModel<MainViewModel>()

    override fun onViewCreated(...) {
        jumpButton.onClick { viewModel.sendEvent(JumpPressEvent) } // псевдокод - посылаем события по кликами (это mvi intent) 


        viewModel.observe(this, ::onStateChanged, ::onEffect)
    }

    private fun onStateChanged(state: ModelData) {
        // drawing images...
    }

    private fun onEffect(effect: ModelEffect) {
        // logging ...
    }
}
```

ModelEffect у нас не несут какой-то смысловой нагрузки, мы просто будем их логировать чтобы наблюдать за тем как ведет себя ViewModel со всей начинкой. В реальных приложениях Effect описывают команды для навигации, запроса пермишенов, toast итп. любые одноразовые действия (которые не должны повторяться при смене конфигурации) в том числе логирование на экран).  

Раз уже мы заговорили о View то можно сразу отметить что на ней будет несколько кнопок для управления героем, которые будут посылать события (нажатия) во ViewModel. Пример кода пркладывать не буду, чтобы не забивать им голову.

На изменения ModelData View будет реагировать максимально примитивно, будет смотреть на текущее состояние героя и менять заранее нарисованные картинки на экране. Главное чтобы видеокарта не перегрелась)

Итак у нас есть View и ViewModel которые умеют обмениваться событиями, на этом работа MVI закончена. Пора смоделировать нашего героя.

## Моделируем героя (StateMachine)

Переходим на сторону ViewModel, приступаем к описанию возможностей героя.

### States

Опишем его состояния, для них удобно использовать sealed class.
В KStateMachine один из способов создать свое состояние это наследоваться от класса DefaultState

```kotlin

sealed class HeroState : DefaultState() {
    object Standing : HeroState()
    object Jumping : HeroState()
    object Ducking : HeroState()
    class AirAttacking : HeroState() {
        var isDownPressed = true
    }
    object NotShooting : HeroState()
    class Shooting : HeroState() {
        lateinit var shootingTimer: Job
    }
}
```

Некоторые состояния содержат данные актуальные для них, к ним мы вернемся позже.
Стоит обратить внимание что наш игрок может стрелять одновременно с другими действиями, например сидеть или стоять, если пробовать описывать все возможные комбинации, мы получим очень большое число состояний-комбинаций, в которых сложно разобраться, поэтому как обсуждалось ранее мы будем использовать концепцию параллельных или ортогональных состояний (parallel states) тут можно почитать документацию https://nsk90.github.io/kstatemachine/#parallel-states

### Events

Также нам понадобятся события от внешнего мира (условно джойстика) чтобы взамидействовать с героем, у нас все события максимально простые и даже не содержат никаких данных, как это часто бывает в реальных приложениях. Они просто описывают те клавиши которые мы нажимаем.

Во всей концепции StateMachine важно относиться к Event именно как к событиям от внешнего мира, а не как к командам, так как наш конечный автомат это источник __правды__ и актуального состояния, а событиями мы его снабжаем извне чтобы информировать его об изменениях в окружении. Как только мы превращаем события в команды, и начинаем __переключать__ состояния принудительно, начинаются проблемы, данные для принятия решений о следующем state начинают расползаться по всему приложению, нарушается целостность и инкапсуляция, вобщем приятного мало.
Иногда грань между событием и командой, очевидна, но иногда она довольно тонкая, поэтому я рекомендую не забывать об этом правиле, при работе с StateMachine, и стремиться оставлять принятие решений на стороне StateMachine, а не снаружи.


```kotlin
sealed interface ControlEvent : Event {
    object JumpPressEvent : ControlEvent
    object JumpCompleteEvent : ControlEvent
    object DuckPressEvent : ControlEvent
    object DuckReleaseEvent : ControlEvent
    object FirePressEvent : ControlEvent
    object FireReleaseEvent : ControlEvent
}
private object OutOfAmmoEvent : ControlEvent
```

`OutOfAmmoEvent` (закончились патроны) помечено как private, потому что это событие которое View не может послать. ViewModel будет генерировать его самостоятельно основываясь на колличестве оставшихся патронов.

### StateMachine

Теперь осталось собрать все вместе, описать структуру и переходы мужду событиями.
Объявляем StateMachine одной из семейства специальных функций:

```kotlin
createStateMachineBlocking(viewModelScope, "Hero", ChildMode.PARALLEL) {
    state("Movement") {
        // ...
    }
    state("Fire") {
        // ...
    }
```

В `KStateMachine` сама StateMachine является родительскис State, так что мы сразу указываем что дочерние события будут "параллельными", аргументом `ChildMode.PARALLEL`. С помощью иерархии событий мы разобьем их на две группы, тех которые относятся к движениям героя (Movement) и тех которые описывают стрельбу ("Fire").

Начнем со стрельбы, тут всего 2 возможнных состояния, так что будет проще разобраться

```kotlin
state("Fire") {
    val shooting = addState(Shooting()) // добавляем состояние Shooting

    addInitialState(NotShooting) { // добавяем и устанавливаем начальное состояние NotShooting
        transition<FirePressEvent> { // объявляем переход в состояние Shooting по событию нажатия на кнопку "огонь" 
            guard = { state.ammoLeft > 0u } // если патронов нет, то начать стрельбу нельзя
            targetState = shooting
        }
    }
    shooting { // настраиваем состояние Shooting
        transition<FireReleaseEvent>(targetState = NotShooting) // если кнопку стрельбы отпустили переходим в состояние NotShooting
        transition<OutOfAmmoEvent>(targetState = NotShooting) // если узнаем что патроны кончились аналогично

        onEntry { // при входе в состояние запускем таймер который будет выпускать патроны с определнной частотой
            shootingTimer = viewModelScope.launch {
                tickerFlow(SHOOTING_INTERVAL_MS).collect {
                    if (state.ammoLeft == 0u)
                        sendEvent(OutOfAmmoEvent) // когда патроны кончились посылаем событие OutOfAmmoEvent
                    else
                        decrementAmmo() // 
                }
            }
        }
        onExit { shootingTimer.cancel() } // при выходе из состяния подчищаем ресурс таймера 
    }
}

private fun decrementAmmo() = intent { // mvi intent (намерение изменить состояние)
    state { copy(ammoLeft = ammoLeft - 1u) } // декремент счетчика патронов 
    sendEffect(ModelEffect.AmmoDecremented) // посылаем эффект в view, наш ui его залогирует.
}
```

Можно заметить что в функции decrementAmmo() от ViewModel к View посылает два похожих события, это новый State с уменьшенным кол-вом патронов, и эффект AmmoDecremented. В данном случае нельзя обойтись только State, так как мы такие события логируем, а логирование не должно повторяться при смене конфигурации и переподписке View на ViewModel.

Также отмечу тут поле `guard` в объявлении `transition`. Оно позволяет объявлять условные переходы основываясь на данных вашего приложения. Такое динамически определяемое поведение StateMachine очень удобно и часто необходимо в реальных приложениях.

Возвращаясь к полям State, тут мы используем shootingTimer это поле состояния Shooting. В KStateMachine состояния это не просто константы (элементы enum) как это часто бывает в минимальных примерах, это полноценные объекты, которые могут инкапсулировать и нести ссобой связаные данные и ресурсы.

Завершающим этапом опишем движения героя
Думаю с тройкой Standing, Jumping, Ducking и так уже все понятно. 

Рассмотрим что такоее состояние AirAttacking. Это атака ногой в момент когда герой находится в прыжке)
Чтобы ее ктивировать пользователь должен назать кнопку "Присесть" пока герой в прыжке. 


```kotlin
state("Movement") {
    val airAttacking = addState(AirAttacking())

    addInitialState(Standing) {
        transition<JumpPressEvent>("Jump", targetState = Jumping)
        transition<DuckPressEvent>("Duck", targetState = Ducking)
    }

    addState(Jumping) {
        onEntry {
            viewModelScope.singleShotTimer(JUMP_DURATION_MS) { // таймер прыжка (что-то вроде гравитации)
                sendEvent(JumpCompleteEvent)
            }
        }
        transition<DuckPressEvent>("AirAttack", targetState = airAttacking)
        transition<JumpCompleteEvent>("Land after jump", targetState = Standing) // когда обычный прыжок закончен переходим в Standing
    }

    addState(Ducking) {
        transition<DuckReleaseEvent>("StandUp", targetState = Standing)
    }

    airAttacking {
        onEntry { isDuckPressed = true } // вместо флажка можно былобы также использовать вложенные состяния (он тут для разнообразия)

        transitionOn<JumpCompleteEvent>("Land after attack") { // если "присяд" все еще зажат, то герой приземляется в сидячем состоянии
            targetState = { if (this@airAttacking.isDuckPressed) Ducking else Standing } 
        }
        transition<DuckPressEvent>("Duck pressed") {
            onTriggered { this@airAttacking.isDuckPressed = true }
        }
        transition<DuckReleaseEvent>("Duck released") {
            onTriggered { this@airAttacking.isDuckPressed = false }
        }
    }
}
```

Как укзано в комментарии isDuckPressed флаг мог бы быть заменен на вложенные состояния. Думаю в боевом приложении подобного плана такие флаги для определения зажатых кнопок понадобились бы довольно часто, так что я бы реализовал их поддержку сразу для всех кнопок и отдельно от "логической" StateMachine, в самостоятельной StateMachine.

На этом конфигураци закончена, можно запустить игру и посмотреть какой получился "геймлпэй")

## Подводим итоги

Хотя у MVI и StateMachine разные предназночения цели и даже момент когда они стали распространенными и популярными в индустрии,
мне кажется, идеи заложенные в них имеют много общего (например реактивность, событийность, инкапсуляция состяния) эти общие черты позволяют этим подоходам удачно сочетаться и дополнять друг друга своими сильными сторонами. Оба подхода могут работать как сами по себе так и вместе. Это предоствляет нам свободу выбора гибкость и максимум контроля на происходящим. Когда MVI само посебе перестает справляться со сложностью создания состояния, его можно дополнить StateMachine и получить более удобное и поддерживаемое решение.

В рассматриваемой реализации MVI не было reducer функции (призванной порождать новое состояние в результате обработки Intent'ов), однако в некоторых MVI фреймворках она присутствует и фактически является switch/when вариантом StateMachine встроенным в сам MVI. Как мы выяснили этот вариант реализации StateMachine имеет ограниченные возможности и работает до поры до времени, поэтому я бы отнес это к минусами (жесткости) такого MVI фреймворка. Внутри такой reducer функции все еще должно быть возможно использовать полноценную реализацию StateMachine, но кажется это менее удобно чем в более минималистичных и гибких MVI реализациях и может не сочетаться с требованиме идемпотентности (отсутствие сайд эффектов) которое часто накладывают на такие reducer фукнции. В защиту StateMachine могу отметить что это требование будет нарушаться всегда как только для работы ViewModel будет требоваться "приватное" состояние, то которое не отправляется во View, но требуется для принятие решения при формировании следующего State. Так что скорее всего в таких MVI реализациях предусмотренно подходящее место где можно расположить StateMachine, аналогично приватному состоянию.

На этом у меня все, спасибо что дочитали до конца)
Пишите свой опыт сочетания MVI и StateMachine в комментариях, будет интересно посмотреть какие фреймворки больше всего используются и на сколько удачно они сочетаются между собой.